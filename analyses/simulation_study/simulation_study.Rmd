---
title: 'Simulation study'
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

```{r setup, message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, tidy=TRUE, echo=FALSE) # Places figures on their own pages
knitr::opts_chunk$set(out.width = '100%', dpi=300)

WhereAmI <- "~/Dropbox/PROOF/Manuscript/mixOmics/diablo/analyses/simulation_study/"

## load libraries
library(tidyverse)
library(amritr)
library(cowplot)
library(knitr)
library(mixOmics)
library(mvtnorm)
library(NMF)
library(plotly)
library(parallel);
no_cores <- detectCores() # number of cores on machine

## source functions
source(paste0(WhereAmI, "simulation_study_functions.R"))
```

# Rationale

The purpose of the simulation study was to 1) study the relationship between the covariance between datasets (controlled through DIABLO design matrix) and the error rate and types of variables selected, 2) explore whether the classification error of a DIABLO model with the full design can improved by incorporating additional independent components, and 3) comparison of classification error rates with existing integrative classification methods (Concatenation and Ensemble).

## Simulation details
Briefly, three omic datasets consisting of 200 samples (split equally over two groups) and 260 variables were generated by modifying the degree of covariance and discrimination, resulting in four types of variables: 30 correlated-discriminatory (corDis) variables, 30 uncorrelated-discriminatory (unCorDis) variables, 100 correlated-nondiscriminatory (corNonDis) variables, and 100 uncorrelated-nondiscriminatory (unCorNonDis) variables. 

```{r out.width="100%"}
img1_path <- "/Users/asingh/Dropbox/PROOF/Manuscript/mixOmics/diablo/analyses/simulation_study/Figures/Figure1A.png"
include_graphics(img1_path)
```

# DIABLO performs competitively with other integrative methods

## Simulation: vary noise and fold-change and compare with other schemes (concatenation/ensembles)

Three integrative classification methods were applied to generate multi-omic biomarkers panels of 180 variables each: a DIABLO model with either a full design (where the sum of correlations between all pairwise combinations of datasets, as well as between each dataset and the phenotypic outcome, were maximised) or the null design (where only the sum of correlations between each dataset and the phenotypic outcome was maximised, see Methods), a concatenation-based sPLSDA classifier which consists of naively combining all datasets into one, and an ensemble of sPLSDA classifiers where a separate sPLSDA classifier was fitted for each omics dataset and the consensus predictions were combined using a majority vote scheme. 

```{r out.width="100%"}
img1_path <- "/Users/asingh/Dropbox/PROOF/Manuscript/mixOmics/diablo/analyses/methods_overview/integrativeMethods.png"
include_graphics(img1_path)
```

> **Integrative prediction frameworks including multi-step approaches (concatenation, ensemble) and DIABLO to identify multi-omics molecular signatures.** Concatenation-based integration combines multiple datasets into a single large dataset, with the aim to predict a phenotype of interest. Ensemble-based classification methods construct a predictive model on each individual dataset before combining the model predictions. None of these approaches account or model relationships between datasets and thus limit our understanding of molecular interactions at multiple functional levels. DIABLO simultaneously maximizes the associations between datasets and a phenotype of interest to identify a correlated set of variables of different omics-types that are also discriminatory. The prediction is based on each omics-associated component derived from the model (see Supplementary Note). All methods presented here are data-driven approaches, which do not use any prior knowledge such as from curated biological databases (eg. protein-protein interactions).

```{r simulationResults, fig.path='Figures/', dev='png', fig.height = 7, fig.width = 18}
J <- 3
fcSeq <- c(0, 1, 2)
noiseSeq <- c(0.2, 0.5, 1)
fc.noise.grid <- expand.grid(fcSeq, noiseSeq)
colnames(fc.noise.grid) <- c("FC", "Noise")
nperms <- 20
J=3; n=100; p_relevant=30; p_irrelevant=100
folds=10; nrepeat = 1; ncomp = 1; 

clust <- makeCluster(no_cores)
clusterExport(clust, varlist=c("simData", "rmvnorm", "fc.noise.grid", "p_relevant", "p_irrelevant", "n", "J", "ncomp", "folds", "nrepeat", "perf.ensemble.splsda"))
result <- parLapply(clust, 1:nperms, function(x){
  library(mvtnorm)
  library(mixOmics)
  library(tidyverse)
  
  varsList <- errList <- list()
  for(h in 1 : nrow(fc.noise.grid)){
  fc <- fc.noise.grid[h, "FC"]
  noise <- fc.noise.grid[h, "Noise"]
  
  ## Generate data given fc and noise
  genDats <- simData(fc=fc, noise=noise, J, n, p_relevant, p_irrelevant, cov=1)
  data <- genDats$data
  Y <- genDats$Y
  
    ## Apply DIABLO full design
  design <- matrix(1, nrow = J, ncol = J)
  diag(design) <- 0
  keepX = list(rep(2*p_relevant, ncomp), rep(2*p_relevant, ncomp), rep(2*p_relevant, ncomp))
  rownames(design) <- colnames(design) <- names(keepX) <- names(data)
  result.full = block.splsda(X = data, Y = Y, ncomp = ncomp, keepX = keepX, design = design)
  diabloFullPanels <- lapply(1:ncomp, function(i) {selectVar(result.full, ncomp=i)[1:J] %>% 
          lapply(., function(j){ j[[1]]})
        }) %>% unlist(.)
  cv.full <- perf(result.full, validation = "Mfold", folds = folds, nrepeat = nrepeat, progressBar = FALSE)
  
  ## Apply DIABLO null design
  design <- matrix(0, nrow = J, ncol = J)
  rownames(design) <- colnames(design) <- names(data)
  result.null = block.splsda(X = data, Y = Y, ncomp = ncomp, keepX = keepX, design = design)
  diabloNullPanels <- lapply(1:ncomp, function(i) {selectVar(result.null, ncomp=i)[1:J] %>% 
          lapply(., function(j){ j[[1]]})
        }) %>% unlist(.)
  cv.null <- perf(result.null, validation = "Mfold", folds = folds, nrepeat = nrepeat, progressBar = FALSE)
  
  ## Concatenation
  concat <- splsda(X = do.call(cbind, data), Y = Y, keepX = rep(2*J*p_relevant/ncomp, ncomp), ncomp = ncomp)
  concatPanels <- lapply(1:ncomp, function(i) {selectVar(concat, ncomp=i)$name}) %>% unlist(.)
  cv.concat <- perf(concat, validation = "Mfold", folds = folds, nrepeat = nrepeat, progressBar = FALSE)
  
  ## Ensemble
  ensemblePanels <- lapply(data, function(i){
    result <- splsda(X = i, Y = Y, keepX = rep(2*p_relevant/ncomp, ncomp), ncomp = ncomp)
    lapply(1:ncomp, function(i) {selectVar(result, ncomp=i)$name}) %>% unlist(.)
  }) %>% unlist()
  cv.ensemble <- perf.ensemble.splsda(data, Y, keepX = rep(p_relevant, 1), ncomp = ncomp, nrepeat = nrepeat, M = folds)
  
  ## Proportion of selected variables
  panels <- list(DIABLO_Full=diabloFullPanels, DIABLO_Null=diabloNullPanels,
                 Concatenation=concatPanels, Ensemble=ensemblePanels)
  vars <- lapply(panels, function(i){
    as.character(sapply(strsplit(i, "\\."), function(i) i[1]))})
  dats <- lapply(panels, function(i){
    as.character(sapply(strsplit(diabloFullPanels, "_"), function(i) paste(i[-1], collapse = "_")))})
  varDat <- cbind(unlist(dats), unlist(vars)) %>% 
    as.data.frame() %>% 
    mutate(dataset=V1, varType = V2, Classifier = rep(names(dats), sapply(dats, length))) %>% 
    dplyr::select(dataset:Classifier)
  varDat$FC <- paste("FC", fc, sep = "_")
  varDat$Noise <- paste("Noise", noise, sep = "_")
  varsList[[h]] <- varDat %>% group_by(varType, Classifier, FC, Noise) %>% 
  summarise(n = n()) %>% 
  complete(varType, nesting(FC, Noise, Classifier),
    fill = list(n = 0))
  
  ## Error rates
  err <- data.frame(error = c(cv.full$WeightedVote.error.rate$max.dist["Overall.BER", ncomp],
                            cv.null$WeightedVote.error.rate$max.dist["Overall.BER", ncomp], 
                            cv.concat$error.rate$BER[ncomp, "max.dist"], cv.ensemble$Mean)) %>% 
         mutate(Classifier = c("DIABLO_Full", "DIABLO_Null", "Concatenation", "Ensemble"))
  err$FC <- paste("FC", fc, sep = "_")
  err$Noise <- paste("Noise", noise, sep = "_")
  errList[[h]] <- err
  }
  vars <- do.call(rbind, varsList)
  err <- do.call(rbind, errList)
  list(vars=vars, err=err)
}) %>% zip_nPure()
stopCluster(clust) 

## Error rates
errorRates <- do.call(rbind, result$err)  %>% 
    mutate(Classifier = factor(Classifier, 
    levels = c("DIABLO_Full", "DIABLO_Null", "Concatenation", "Ensemble"))) %>% 
  group_by(Classifier, FC, Noise) %>% 
  summarise(Mean = mean(error), SD = sd(error)) %>% 
  ungroup %>% 
  mutate(FC = gsub("FC_", "FC=", FC), Noise = gsub("Noise_", "Noise=", Noise)) %>% 
  ggplot(aes(x = Classifier, y = Mean)) +
  geom_bar(stat = "identity") + 
  geom_errorbar(aes(ymin = Mean-SD, ymax = Mean+SD)) +
  facet_grid(FC ~ Noise) +
  customTheme(sizeStripFont = 25, xAngle = -45, hjust = 0, vjust = 1, 
              xSize = 15, ySize = 15, xAxisSize = 15, yAxisSize = 15) +
  ylab("MeanÂ±SD of error rate \n 10-fold cross-validation over 20 simulations") +
  xlab("Integrative Classifiers") +
  geom_hline(yintercept = 0.50, linetype = "dashed")

### Selected variables
selectedVars <- do.call(rbind, result$vars) %>% ungroup %>% 
    mutate(Classifier = factor(Classifier, 
    levels = c("DIABLO_Full", "DIABLO_Null", "Concatenation", "Ensemble"))) %>% 
  group_by(Classifier, FC, Noise, varType) %>% 
  summarise(Mean = mean(n), SD = sd(n)) %>% 
  ungroup %>% 
    mutate(FC = gsub("FC_", "FC=", FC), Noise = gsub("Noise_", "Noise=", Noise)) %>% 
  ggplot(aes(x = Classifier, y = Mean, color = varType, fill = varType)) +
  geom_bar(stat = "identity") + 
  #geom_errorbar(aes(ymin = Mean, ymax = Mean+SD), position="dodge") +
  facet_grid(FC ~ Noise) +
  customTheme(sizeStripFont = 25, xAngle = -45, hjust = 0, vjust = 1, 
              xSize = 15, ySize = 15, xAxisSize = 15, yAxisSize = 15) +
  ylab("Average number of selected variables \n across 3 datasets over 20 simulations") +
  geom_hline(yintercept = 180, linetype = "dashed") + xlab("Integrative Classifiers") +
  scale_y_continuous(breaks=c(60,120,180))

plot_grid(errorRates, selectedVars, labels = c("", ""), label_size = 30)

```

> The covariance between datasets was held constant at 1, whereas the fold-change was varied from 0-2, and noise was varied from 0.2-1. As expected the error rate was roughly 50% when the fold-change was zero, regardless of noise level for all methods. When the fold-change was set to 1, the DIABLO model the full design (DIABLO_Full) had a higher error rate as compared to the other methods, for noise levels less than 1. However, when the noise level was increased to match the level of the fold-change all methods performed similarly. When the fold-change was increased to 2 (higher than both the covariance and noise levels) the DIABLO_Full model performed similarly with the other methods.

# Trade-off between correlation and discrimination

Contour plots of the average error rate (10-fold cross-validation) over 20 simulations at different levels of covariance and fold-change, using DIABLO with the full and null design, retaining 1 component.

```{r}
## vary correlation and fold-change (keep the level of discrimination of relevant correlated and uncorrelated the same)
fc <- c(0.5, 1, 2, 4)
cov <- c(0, 5, 10, 15)
noise <- 0.5
p_relevant <- 30; p_irrelevant <- 100; n <- 100; J <- 3;
keepX <- list(rep(p_relevant, 1), rep(p_relevant, 1), rep(p_relevant, 1))
names(keepX) <- c("Dataset1", "Dataset2", "Dataset3")
designFull <- matrix(1, nrow = J, ncol = J)
diag(designFull) <- 0
designNull <- matrix(0, nrow = J, ncol = J)
nperms <- 20

clust <- makeCluster(no_cores)
clusterExport(clust, varlist=c("simData", "rmvnorm", "fc", "cov", "noise", "p_relevant", "p_irrelevant", "n", "J", "keepX", "designFull", "designNull"))
result <- parLapply(clust, 1:nperms, function(x){
  library(mvtnorm)
  library(mixOmics)
  library(tidyverse)
  
  outputs <- list()
  outputs$errFull <- outputs$errNull <- outputs$p_corDisFull <- outputs$p_unCorDisFull <- outputs$p_corNonDisFull <- outputs$p_unCorNonDisFull <- outputs$p_corDisNull <- outputs$p_unCorDisNull <- outputs$p_corNonDisNull <- outputs$p_unCorNonDisNull <-  matrix(0, nr = length(fc), nc = length(cov))
  rownames(outputs$errFull) <- rownames(outputs$errNull) <- rownames(outputs$p_corDisFull) <- rownames(outputs$p_unCorDisFull) <- rownames(outputs$p_corNonDisFull) <- rownames(outputs$p_unCorNonDisFull) <- rownames(outputs$p_corDisNull) <- rownames(outputs$p_unCorDisNull) <- rownames(outputs$p_corNonDisNull) <- rownames(outputs$p_unCorNonDisNull) <- paste(rep("fc", length(fc)), fc, sep="_")
  colnames(outputs$errFull) <- colnames(outputs$errNull) <- colnames(outputs$p_corDisFull) <- colnames(outputs$p_unCorDisFull) <- colnames(outputs$p_corNonDisFull) <- colnames(outputs$p_unCorNonDisFull) <- colnames(outputs$p_corDisNull) <- colnames(outputs$p_unCorDisNull) <- colnames(outputs$p_corNonDisNull) <- colnames(outputs$p_unCorNonDisNull) <- paste(rep("cov", length(cov)), cov, sep="_")
  
  for(i in 1:length(fc)){
    for(j in 1:length(cov)){
      data <- simData(fc=fc[i], noise, J, n, p_relevant, p_irrelevant, cov=cov[j])
      
      ## Full design (diag0)
      resultFull = block.splsda(X = data$data, Y = data$Y, ncomp = 1, keepX = keepX, design = designFull)
      diabloFullPanels <- selectVar(resultFull)[1:J] %>% lapply(., function(i){ i[[1]] }) %>% unlist(.)
      diabloFullPanels <- unlist(lapply(strsplit(as.character(diabloFullPanels), "_"), function(i) i[1]))
      outputs$p_corDisFull[i, j] <- length(grep("corDis", diabloFullPanels))
      outputs$p_unCorDisFull[i, j] <- length(grep("unCorDis", diabloFullPanels))
      outputs$p_corNonDisFull[i, j] <- length(grep("corNonDis", diabloFullPanels))
      outputs$p_unCorNonDisFull[i, j] <- length(grep("unCorNonDis", diabloFullPanels))
      cv.full <- perf(resultFull, validation = "Mfold", folds = 10, nrepeat = 1, progressBar = FALSE)
      outputs$errFull[i, j] <- cv.full$WeightedPredict.error.rate["Overall.ER", ]
      
      ## Null design
      resultNull = block.splsda(X = data$data, Y = data$Y, ncomp = 1, keepX = keepX, design = designNull)
      diabloNullPanels <- selectVar(resultNull)[1:J] %>% lapply(., function(i){ i[[1]] }) %>% unlist(.)
      diabloNullPanels <- unlist(lapply(strsplit(as.character(diabloNullPanels), "_"), function(i) i[1]))
      outputs$p_corDisNull[i, j] <- length(grep("corDis", diabloNullPanels))
      outputs$p_unCorDisNull[i, j] <- length(grep("unCorDis", diabloNullPanels))
      outputs$p_corNonDisNull[i, j] <- length(grep("corNonDis", diabloNullPanels))
      outputs$p_unCorNonDisNull[i, j] <- length(grep("unCorNonDis", diabloNullPanels))
      cv.null <- perf(resultNull, validation = "Mfold", folds = 10, nrepeat = 1, progressBar = FALSE)
      outputs$errNull[i, j] <- cv.null$WeightedPredict.error.rate["Overall.ER", ]
    }
  }
  outputs
}) %>% amritr::zip_nPure()
stopCluster(clust)  
```

### Full design

```{r out.height="50%"}
m <- list(l = 50,r = 0,b = 50,t = 25,pad = 4)
### Full design (diag 0)
zFull=(Reduce("+", result$errFull)/length(result$errFull))
plot_ly(y=fc, x=cov,z=zFull, type="contour", contours = list(showlabels = TRUE), colorscale = 'Jet') %>%
  layout(
    title = "Error rate, Full design, 1 component",
    xaxis = list(title = "covariance between datasets"),
      yaxis = list(title = "fold-change"), margin=m)
```

### Null design

```{r out.height="50%"}
### Null design
zNull=(Reduce("+", result$errNull)/length(result$errNull))
plot_ly(y=fc, x=cov,z=zNull, type="contour", contours = list(showlabels = TRUE), colorscale = 'Jet') %>%
  layout(
    title = "Error rate, Null design, 1 component",
    xaxis = list(title = "covariance between datasets"),
    yaxis = list(title = "fold-change"), margin=m)
```

## types of variables selected

```{r}
### uncorDis
p_unCorDisFull <- do.call(rbind, result$p_unCorDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorDisFull[[1]]), length(result$p_unCorDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorDis", design = "Full")

p_unCorDisNull <- do.call(rbind, result$p_unCorDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorDisNull[[1]]), length(result$p_unCorDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorDis", design = "Null")

### corDis
p_corDisFull <- do.call(rbind, result$p_corDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corDisFull[[1]]), length(result$p_corDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corDis", design = "Full")

p_corDisNull <- do.call(rbind, result$p_corDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corDisNull[[1]]), length(result$p_corDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corDis", design = "Null")

### uncorNonDis
p_unCorNonDisFull <- do.call(rbind, result$p_unCorNonDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorNonDisFull[[1]]), length(result$p_unCorNonDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorNonDis", design = "Full")

p_unCorNonDisNull <- do.call(rbind, result$p_unCorNonDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorNonDisNull[[1]]), length(result$p_unCorNonDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorNonDis", design = "Null")

### corNonDis
p_corNonDisFull <- do.call(rbind, result$p_corNonDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corNonDisFull[[1]]), length(result$p_corNonDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corNonDis", design = "Full")

p_corNonDisNull <- do.call(rbind, result$p_corNonDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corNonDisNull[[1]]), length(result$p_corNonDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corNonDis", design = "Null")

nVars <- rbind(p_unCorDisFull, p_unCorDisNull, p_corDisFull, p_corDisNull,
  p_unCorNonDisFull,p_unCorNonDisNull, p_corNonDisFull, p_corNonDisNull)

nVars %>% 
  mutate(cov = factor(cov), FC=gsub("fc_","FC=", fc)) %>% 
  ggplot(aes(x = cov, y = mean_np, fill = varType, color = varType)) +
  geom_bar(stat = "identity") + facet_grid(design~FC) +
  geom_hline(yintercept = 90, linetype="dashed") +
  ylab("Average number of variables selected \n across 3 datasets (over 20 simulations)") +
  xlab("covariance between datasets") +
  customTheme(sizeStripFont = 15, xAngle = 0, hjust = 0.5, vjust = 0.5, xSize = 10, ySize = 10, xAxisSize = 10, yAxisSize = 10)

```

> As can be observed, increasing the covariance between datasets significantly increases the error rate (blue to red) for a given fold-change in the case of the full design but not the null design. 

## Improving predictive performance by incorporating independent information (ncomp = 2)

```{r}
ncomp <- 2
keepX <- list(rep(p_relevant/ncomp, ncomp), rep(p_relevant/ncomp, ncomp), rep(p_relevant/ncomp, ncomp))
names(keepX) <- c("Dataset1", "Dataset2", "Dataset3")

clust <- makeCluster(no_cores)
clusterExport(clust, varlist=c("simData", "rmvnorm", "fc", "cov", "noise", "p_relevant", "p_irrelevant", "n", "J", "keepX", "designFull", "designNull", "ncomp"))
result <- parLapply(clust, 1:nperms, function(x){
  library(mvtnorm)
  library(mixOmics)
  library(tidyverse)
  
  outputs <- list()
  outputs$errFull <- outputs$errNull <- outputs$p_corDisFull <- outputs$p_unCorDisFull <- outputs$p_corNonDisFull <- outputs$p_unCorNonDisFull <- outputs$p_corDisNull <- outputs$p_unCorDisNull <- outputs$p_corNonDisNull <- outputs$p_unCorNonDisNull <-  matrix(0, nr = length(fc), nc = length(cov))
  rownames(outputs$errFull) <- rownames(outputs$errNull) <- rownames(outputs$p_corDisFull) <- rownames(outputs$p_unCorDisFull) <- rownames(outputs$p_corNonDisFull) <- rownames(outputs$p_unCorNonDisFull) <- rownames(outputs$p_corDisNull) <- rownames(outputs$p_unCorDisNull) <- rownames(outputs$p_corNonDisNull) <- rownames(outputs$p_unCorNonDisNull) <- paste(rep("fc", length(fc)), fc, sep="_")
  colnames(outputs$errFull) <- colnames(outputs$errNull) <- colnames(outputs$p_corDisFull) <- colnames(outputs$p_unCorDisFull) <- colnames(outputs$p_corNonDisFull) <- colnames(outputs$p_unCorNonDisFull) <- colnames(outputs$p_corDisNull) <- colnames(outputs$p_unCorDisNull) <- colnames(outputs$p_corNonDisNull) <- colnames(outputs$p_unCorNonDisNull) <- paste(rep("cov", length(cov)), cov, sep="_")
  
  for(i in 1:length(fc)){
    for(j in 1:length(cov)){
      data <- simData(fc=fc[i], noise, J, n, p_relevant, p_irrelevant, cov=cov[j])
      
      ## Full design (diag0)
      resultFull = block.splsda(X = data$data, Y = data$Y, ncomp = ncomp, keepX = keepX, design = designFull)
      diabloFullPanels <- lapply(1:ncomp, function(i) {selectVar(resultFull, ncomp=i)[1:J] %>% 
          lapply(., function(j){ j[[1]]})
        }) %>% unlist(.)
      diabloFullPanels <- unlist(lapply(strsplit(as.character(diabloFullPanels), "_"), function(i) i[1]))
      outputs$p_corDisFull[i, j] <- length(grep("corDis", diabloFullPanels))
      outputs$p_unCorDisFull[i, j] <- length(grep("unCorDis", diabloFullPanels))
      outputs$p_corNonDisFull[i, j] <- length(grep("corNonDis", diabloFullPanels))
      outputs$p_unCorNonDisFull[i, j] <- length(grep("unCorNonDis", diabloFullPanels))
      cv.full <- perf(resultFull, validation = "Mfold", folds = 10, nrepeat = 1, progressBar = FALSE)
      outputs$errFull[i, j] <- cv.full$WeightedPredict.error.rate["Overall.ER", ncomp]
      
      ## Null design
      resultNull = block.splsda(X = data$data, Y = data$Y, ncomp = ncomp, keepX = keepX, design = designNull)
      diabloNullPanels <- lapply(1:ncomp, function(i) {selectVar(resultNull, ncomp=i)[1:J] %>% 
          lapply(., function(j){ j[[1]]})
        }) %>% unlist(.)
      diabloNullPanels <- unlist(lapply(strsplit(as.character(diabloNullPanels), "_"), function(i) i[1]))
      outputs$p_corDisNull[i, j] <- length(grep("corDis", diabloNullPanels))
      outputs$p_unCorDisNull[i, j] <- length(grep("unCorDis", diabloNullPanels))
      outputs$p_corNonDisNull[i, j] <- length(grep("corNonDis", diabloNullPanels))
      outputs$p_unCorNonDisNull[i, j] <- length(grep("unCorNonDis", diabloNullPanels))
      cv.null <- perf(resultNull, validation = "Mfold", folds = 10, nrepeat = 1, progressBar = FALSE)
      outputs$errNull[i, j] <- cv.null$WeightedPredict.error.rate["Overall.ER", ncomp]
    }
  }
  outputs
}) %>% amritr::zip_nPure()
stopCluster(clust)  

```

### Full design

```{r out.height="50%"}
## plot error rates
m <- list(l = 50,r = 0,b = 50,t = 25,pad = 4)
### Full design (diag 0)
zFull=(Reduce("+", result$errFull)/length(result$errFull))
plot_ly(y=fc, x=cov,z=zFull, type="contour", contours = list(showlabels = TRUE), colorscale = 'Jet') %>%
  layout(
    title = "Error rate, Full design, 2 components",
    xaxis = list(title = "covariance between datasets"),
      yaxis = list(title = "fold-change"), margin=m)
```

### Null design

```{r out.height="50%"}
### Null design
zNull=(Reduce("+", result$errNull)/length(result$errNull))
plot_ly(y=fc, x=cov,z=zNull, type="contour", contours = list(showlabels = TRUE), colorscale = 'Jet') %>%
  layout(
    title = "Error rate, Null design, 2 components",
    xaxis = list(title = "covariance between datasets"),
    yaxis = list(title = "effect size"), margin=m)

```

## types of variables selected

```{r}
### uncorDis
p_unCorDisFull <- do.call(rbind, result$p_unCorDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorDisFull[[1]]), length(result$p_unCorDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorDis", design = "Full")

p_unCorDisNull <- do.call(rbind, result$p_unCorDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorDisNull[[1]]), length(result$p_unCorDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorDis", design = "Null")

### corDis
p_corDisFull <- do.call(rbind, result$p_corDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corDisFull[[1]]), length(result$p_corDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corDis", design = "Full")

p_corDisNull <- do.call(rbind, result$p_corDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corDisNull[[1]]), length(result$p_corDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corDis", design = "Null")

### uncorNonDis
p_unCorNonDisFull <- do.call(rbind, result$p_unCorNonDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorNonDisFull[[1]]), length(result$p_unCorNonDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorNonDis", design = "Full")

p_unCorNonDisNull <- do.call(rbind, result$p_unCorNonDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_unCorNonDisNull[[1]]), length(result$p_unCorNonDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "unCorNonDis", design = "Null")

### corNonDis
p_corNonDisFull <- do.call(rbind, result$p_corNonDisFull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corNonDisFull[[1]]), length(result$p_corNonDisFull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corNonDis", design = "Full")

p_corNonDisNull <- do.call(rbind, result$p_corNonDisNull) %>% 
  as.data.frame() %>% 
  mutate(fc = rep(rownames(result$p_corNonDisNull[[1]]), length(result$p_corNonDisNull))) %>% 
  gather(cov, np, -fc) %>% 
  group_by(cov, fc) %>% 
  summarise(mean_np = mean(np), sd_np = sd(np)) %>% 
  ungroup %>% 
  mutate(cov = as.numeric(sapply(strsplit(cov, "_"), function(i) i[2]))) %>% 
  mutate(varType = "corNonDis", design = "Null")

nVars <- rbind(p_unCorDisFull, p_unCorDisNull, p_corDisFull, p_corDisNull,
  p_unCorNonDisFull,p_unCorNonDisNull, p_corNonDisFull,  p_corNonDisNull)

nVars %>% 
  mutate(cov = factor(cov), FC=gsub("fc_","FC=", fc)) %>% 
  ggplot(aes(x = cov, y = mean_np, fill = varType, color = varType)) +
  geom_bar(stat = "identity") + facet_grid(design~FC) +
  geom_hline(yintercept = 90, linetype="dashed") +
  ylab("Average number of variables selected \n across 3 datasets (over 20 simulations)") +
  xlab("covariance between datasets") +
  customTheme(sizeStripFont = 15, xAngle = 0, hjust = 0.5, vjust = 0.5, xSize = 10, ySize = 10, xAxisSize = 10, yAxisSize = 10)

```

> when additional independent information is added in the DIABLO (full design) model by retaining additional components (but retaining the number of variables), the error rate significantly improves and becomes more similar to that of the DIABLO (null design) model.

# Conclusion

This simulation highlights how the design (connection between datasets) affects the flexibility of the DIABLO model, resulting in a trade-off between discrimination or correlation. DIABLO_null focused on selecting discriminatory variables and disregarded most of the correlation between datasets (null design), whereas DIABLO_full selected highly correlated variables across all datasets. Since the variables selected by DIABLO_full reflect the correlation structure between biological compartments, we hypothesized that they might provide a balance between prediction accuracy and biological insight.
